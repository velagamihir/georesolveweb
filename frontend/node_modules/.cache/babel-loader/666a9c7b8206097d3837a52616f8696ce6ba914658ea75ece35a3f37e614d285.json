{"ast":null,"code":"\"use client\";\n\n// src/collection-legacy.tsx\nimport _classPrivateFieldInitSpec from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _keys;\nconst _excluded = [\"scope\", \"children\"],\n  _excluded2 = [\"state\"],\n  _excluded3 = [\"scope\", \"children\"];\nimport React from \"react\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createSlot } from \"@radix-ui/react-slot\";\nimport { jsx } from \"react/jsx-runtime\";\nfunction createCollection(name) {\n  const PROVIDER_NAME = name + \"CollectionProvider\";\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {\n    collectionRef: {\n      current: null\n    },\n    itemMap: /* @__PURE__ */new Map()\n  });\n  const CollectionProvider = props => {\n    const {\n      scope,\n      children\n    } = props;\n    const ref = React.useRef(null);\n    const itemMap = React.useRef(/* @__PURE__ */new Map()).current;\n    return /* @__PURE__ */jsx(CollectionProviderImpl, {\n      scope,\n      itemMap,\n      collectionRef: ref,\n      children\n    });\n  };\n  CollectionProvider.displayName = PROVIDER_NAME;\n  const COLLECTION_SLOT_NAME = name + \"CollectionSlot\";\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef((props, forwardedRef) => {\n    const {\n      scope,\n      children\n    } = props;\n    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n    const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n    return /* @__PURE__ */jsx(CollectionSlotImpl, {\n      ref: composedRefs,\n      children\n    });\n  });\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n  const ITEM_SLOT_NAME = name + \"CollectionItemSlot\";\n  const ITEM_DATA_ATTR = \"data-radix-collection-item\";\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef((props, forwardedRef) => {\n    const {\n        scope,\n        children\n      } = props,\n      itemData = _objectWithoutProperties(props, _excluded);\n    const ref = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n    React.useEffect(() => {\n      context.itemMap.set(ref, _objectSpread({\n        ref\n      }, itemData));\n      return () => void context.itemMap.delete(ref);\n    });\n    return /* @__PURE__ */jsx(CollectionItemSlotImpl, _objectSpread(_objectSpread({}, {\n      [ITEM_DATA_ATTR]: \"\"\n    }), {}, {\n      ref: composedRefs,\n      children\n    }));\n  });\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n  function useCollection(scope) {\n    const context = useCollectionContext(name + \"CollectionConsumer\", scope);\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(\"[\".concat(ITEM_DATA_ATTR, \"]\")));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort((a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current));\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n    return getItems;\n  }\n  return [{\n    Provider: CollectionProvider,\n    Slot: CollectionSlot,\n    ItemSlot: CollectionItemSlot\n  }, useCollection, createCollectionScope];\n}\n\n// src/collection.tsx\nimport React2 from \"react\";\nimport { createContextScope as createContextScope2 } from \"@radix-ui/react-context\";\nimport { useComposedRefs as useComposedRefs2 } from \"@radix-ui/react-compose-refs\";\nimport { createSlot as createSlot2 } from \"@radix-ui/react-slot\";\n\n// src/ordered-dictionary.ts\nvar __instanciated = /* @__PURE__ */new WeakMap();\nvar OrderedDict = (_keys = /*#__PURE__*/new WeakMap(), class _OrderedDict extends Map {\n  constructor(entries) {\n    super(entries);\n    _classPrivateFieldInitSpec(this, _keys, void 0);\n    _classPrivateFieldSet(_keys, this, [...super.keys()]);\n    __instanciated.set(this, true);\n  }\n  set(key, value) {\n    if (__instanciated.get(this)) {\n      if (this.has(key)) {\n        _classPrivateFieldGet(_keys, this)[_classPrivateFieldGet(_keys, this).indexOf(key)] = key;\n      } else {\n        _classPrivateFieldGet(_keys, this).push(key);\n      }\n    }\n    super.set(key, value);\n    return this;\n  }\n  insert(index, key, value) {\n    const has = this.has(key);\n    const length = _classPrivateFieldGet(_keys, this).length;\n    const relativeIndex = toSafeInteger(index);\n    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n    if (safeIndex === this.size || has && safeIndex === this.size - 1 || safeIndex === -1) {\n      this.set(key, value);\n      return this;\n    }\n    const size = this.size + (has ? 0 : 1);\n    if (relativeIndex < 0) {\n      actualIndex++;\n    }\n    const keys = [..._classPrivateFieldGet(_keys, this)];\n    let nextValue;\n    let shouldSkip = false;\n    for (let i = actualIndex; i < size; i++) {\n      if (actualIndex === i) {\n        let nextKey = keys[i];\n        if (keys[i] === key) {\n          nextKey = keys[i + 1];\n        }\n        if (has) {\n          this.delete(key);\n        }\n        nextValue = this.get(nextKey);\n        this.set(key, value);\n      } else {\n        if (!shouldSkip && keys[i - 1] === key) {\n          shouldSkip = true;\n        }\n        const currentKey = keys[shouldSkip ? i : i - 1];\n        const currentValue = nextValue;\n        nextValue = this.get(currentKey);\n        this.delete(currentKey);\n        this.set(currentKey, currentValue);\n      }\n    }\n    return this;\n  }\n  with(index, key, value) {\n    const copy = new _OrderedDict(this);\n    copy.insert(index, key, value);\n    return copy;\n  }\n  before(key) {\n    const index = _classPrivateFieldGet(_keys, this).indexOf(key) - 1;\n    if (index < 0) {\n      return void 0;\n    }\n    return this.entryAt(index);\n  }\n  /**\n   * Sets a new key-value pair at the position before the given key.\n   */\n  setBefore(key, newKey, value) {\n    const index = _classPrivateFieldGet(_keys, this).indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index, newKey, value);\n  }\n  after(key) {\n    let index = _classPrivateFieldGet(_keys, this).indexOf(key);\n    index = index === -1 || index === this.size - 1 ? -1 : index + 1;\n    if (index === -1) {\n      return void 0;\n    }\n    return this.entryAt(index);\n  }\n  /**\n   * Sets a new key-value pair at the position after the given key.\n   */\n  setAfter(key, newKey, value) {\n    const index = _classPrivateFieldGet(_keys, this).indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index + 1, newKey, value);\n  }\n  first() {\n    return this.entryAt(0);\n  }\n  last() {\n    return this.entryAt(-1);\n  }\n  clear() {\n    _classPrivateFieldSet(_keys, this, []);\n    return super.clear();\n  }\n  delete(key) {\n    const deleted = super.delete(key);\n    if (deleted) {\n      _classPrivateFieldGet(_keys, this).splice(_classPrivateFieldGet(_keys, this).indexOf(key), 1);\n    }\n    return deleted;\n  }\n  deleteAt(index) {\n    const key = this.keyAt(index);\n    if (key !== void 0) {\n      return this.delete(key);\n    }\n    return false;\n  }\n  at(index) {\n    const key = at(_classPrivateFieldGet(_keys, this), index);\n    if (key !== void 0) {\n      return this.get(key);\n    }\n  }\n  entryAt(index) {\n    const key = at(_classPrivateFieldGet(_keys, this), index);\n    if (key !== void 0) {\n      return [key, this.get(key)];\n    }\n  }\n  indexOf(key) {\n    return _classPrivateFieldGet(_keys, this).indexOf(key);\n  }\n  keyAt(index) {\n    return at(_classPrivateFieldGet(_keys, this), index);\n  }\n  from(key, offset) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return void 0;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.at(dest);\n  }\n  keyFrom(key, offset) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return void 0;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.keyAt(dest);\n  }\n  find(predicate, thisArg) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return entry;\n      }\n      index++;\n    }\n    return void 0;\n  }\n  findIndex(predicate, thisArg) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return index;\n      }\n      index++;\n    }\n    return -1;\n  }\n  filter(predicate, thisArg) {\n    const entries = [];\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        entries.push(entry);\n      }\n      index++;\n    }\n    return new _OrderedDict(entries);\n  }\n  map(callbackfn, thisArg) {\n    const entries = [];\n    let index = 0;\n    for (const entry of this) {\n      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);\n      index++;\n    }\n    return new _OrderedDict(entries);\n  }\n  reduce() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const [callbackfn, initialValue] = args;\n    let index = 0;\n    let accumulator = initialValue !== null && initialValue !== void 0 ? initialValue : this.at(0);\n    for (const entry of this) {\n      if (index === 0 && args.length === 1) {\n        accumulator = entry;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n      index++;\n    }\n    return accumulator;\n  }\n  reduceRight() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const [callbackfn, initialValue] = args;\n    let accumulator = initialValue !== null && initialValue !== void 0 ? initialValue : this.at(-1);\n    for (let index = this.size - 1; index >= 0; index--) {\n      const entry = this.at(index);\n      if (index === this.size - 1 && args.length === 1) {\n        accumulator = entry;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n    }\n    return accumulator;\n  }\n  toSorted(compareFn) {\n    const entries = [...this.entries()].sort(compareFn);\n    return new _OrderedDict(entries);\n  }\n  toReversed() {\n    const reversed = new _OrderedDict();\n    for (let index = this.size - 1; index >= 0; index--) {\n      const key = this.keyAt(index);\n      const element = this.get(key);\n      reversed.set(key, element);\n    }\n    return reversed;\n  }\n  toSpliced() {\n    const entries = [...this.entries()];\n    entries.splice(...arguments);\n    return new _OrderedDict(entries);\n  }\n  slice(start, end) {\n    const result = new _OrderedDict();\n    let stop = this.size - 1;\n    if (start === void 0) {\n      return result;\n    }\n    if (start < 0) {\n      start = start + this.size;\n    }\n    if (end !== void 0 && end > 0) {\n      stop = end - 1;\n    }\n    for (let index = start; index <= stop; index++) {\n      const key = this.keyAt(index);\n      const element = this.get(key);\n      result.set(key, element);\n    }\n    return result;\n  }\n  every(predicate, thisArg) {\n    let index = 0;\n    for (const entry of this) {\n      if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return false;\n      }\n      index++;\n    }\n    return true;\n  }\n  some(predicate, thisArg) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return true;\n      }\n      index++;\n    }\n    return false;\n  }\n});\nfunction at(array, index) {\n  if (\"at\" in Array.prototype) {\n    return Array.prototype.at.call(array, index);\n  }\n  const actualIndex = toSafeIndex(array, index);\n  return actualIndex === -1 ? void 0 : array[actualIndex];\n}\nfunction toSafeIndex(array, index) {\n  const length = array.length;\n  const relativeIndex = toSafeInteger(index);\n  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n}\nfunction toSafeInteger(number) {\n  return number !== number || number === 0 ? 0 : Math.trunc(number);\n}\n\n// src/collection.tsx\nimport { jsx as jsx2 } from \"react/jsx-runtime\";\nfunction createCollection2(name) {\n  const PROVIDER_NAME = name + \"CollectionProvider\";\n  const [createCollectionContext, createCollectionScope] = createContextScope2(PROVIDER_NAME);\n  const [CollectionContextProvider, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {\n    collectionElement: null,\n    collectionRef: {\n      current: null\n    },\n    collectionRefObject: {\n      current: null\n    },\n    itemMap: new OrderedDict(),\n    setItemMap: () => void 0\n  });\n  const CollectionProvider = _ref => {\n    let {\n        state\n      } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded2);\n    return state ? /* @__PURE__ */jsx2(CollectionProviderImpl, _objectSpread(_objectSpread({}, props), {}, {\n      state\n    })) : /* @__PURE__ */jsx2(CollectionInit, _objectSpread({}, props));\n  };\n  CollectionProvider.displayName = PROVIDER_NAME;\n  const CollectionInit = props => {\n    const state = useInitCollection();\n    return /* @__PURE__ */jsx2(CollectionProviderImpl, _objectSpread(_objectSpread({}, props), {}, {\n      state\n    }));\n  };\n  CollectionInit.displayName = PROVIDER_NAME + \"Init\";\n  const CollectionProviderImpl = props => {\n    const {\n      scope,\n      children,\n      state\n    } = props;\n    const ref = React2.useRef(null);\n    const [collectionElement, setCollectionElement] = React2.useState(null);\n    const composeRefs = useComposedRefs2(ref, setCollectionElement);\n    const [itemMap, setItemMap] = state;\n    React2.useEffect(() => {\n      if (!collectionElement) return;\n      const observer = getChildListObserver(() => {});\n      observer.observe(collectionElement, {\n        childList: true,\n        subtree: true\n      });\n      return () => {\n        observer.disconnect();\n      };\n    }, [collectionElement]);\n    return /* @__PURE__ */jsx2(CollectionContextProvider, {\n      scope,\n      itemMap,\n      setItemMap,\n      collectionRef: composeRefs,\n      collectionRefObject: ref,\n      collectionElement,\n      children\n    });\n  };\n  CollectionProviderImpl.displayName = PROVIDER_NAME + \"Impl\";\n  const COLLECTION_SLOT_NAME = name + \"CollectionSlot\";\n  const CollectionSlotImpl = createSlot2(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React2.forwardRef((props, forwardedRef) => {\n    const {\n      scope,\n      children\n    } = props;\n    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n    const composedRefs = useComposedRefs2(forwardedRef, context.collectionRef);\n    return /* @__PURE__ */jsx2(CollectionSlotImpl, {\n      ref: composedRefs,\n      children\n    });\n  });\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n  const ITEM_SLOT_NAME = name + \"CollectionItemSlot\";\n  const ITEM_DATA_ATTR = \"data-radix-collection-item\";\n  const CollectionItemSlotImpl = createSlot2(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React2.forwardRef((props, forwardedRef) => {\n    const {\n        scope,\n        children\n      } = props,\n      itemData = _objectWithoutProperties(props, _excluded3);\n    const ref = React2.useRef(null);\n    const [element, setElement] = React2.useState(null);\n    const composedRefs = useComposedRefs2(forwardedRef, ref, setElement);\n    const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n    const {\n      setItemMap\n    } = context;\n    const itemDataRef = React2.useRef(itemData);\n    if (!shallowEqual(itemDataRef.current, itemData)) {\n      itemDataRef.current = itemData;\n    }\n    const memoizedItemData = itemDataRef.current;\n    React2.useEffect(() => {\n      const itemData2 = memoizedItemData;\n      setItemMap(map => {\n        if (!element) {\n          return map;\n        }\n        if (!map.has(element)) {\n          map.set(element, _objectSpread(_objectSpread({}, itemData2), {}, {\n            element\n          }));\n          return map.toSorted(sortByDocumentPosition);\n        }\n        return map.set(element, _objectSpread(_objectSpread({}, itemData2), {}, {\n          element\n        })).toSorted(sortByDocumentPosition);\n      });\n      return () => {\n        setItemMap(map => {\n          if (!element || !map.has(element)) {\n            return map;\n          }\n          map.delete(element);\n          return new OrderedDict(map);\n        });\n      };\n    }, [element, memoizedItemData, setItemMap]);\n    return /* @__PURE__ */jsx2(CollectionItemSlotImpl, _objectSpread(_objectSpread({}, {\n      [ITEM_DATA_ATTR]: \"\"\n    }), {}, {\n      ref: composedRefs,\n      children\n    }));\n  });\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n  function useInitCollection() {\n    return React2.useState(new OrderedDict());\n  }\n  function useCollection(scope) {\n    const {\n      itemMap\n    } = useCollectionContext(name + \"CollectionConsumer\", scope);\n    return itemMap;\n  }\n  const functions = {\n    createCollectionScope,\n    useCollection,\n    useInitCollection\n  };\n  return [{\n    Provider: CollectionProvider,\n    Slot: CollectionSlot,\n    ItemSlot: CollectionItemSlot\n  }, functions];\n}\nfunction shallowEqual(a, b) {\n  if (a === b) return true;\n  if (typeof a !== \"object\" || typeof b !== \"object\") return false;\n  if (a == null || b == null) return false;\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if (a[key] !== b[key]) return false;\n  }\n  return true;\n}\nfunction isElementPreceding(a, b) {\n  return !!(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);\n}\nfunction sortByDocumentPosition(a, b) {\n  return !a[1].element || !b[1].element ? 0 : isElementPreceding(a[1].element, b[1].element) ? -1 : 1;\n}\nfunction getChildListObserver(callback) {\n  const observer = new MutationObserver(mutationsList => {\n    for (const mutation of mutationsList) {\n      if (mutation.type === \"childList\") {\n        callback();\n        return;\n      }\n    }\n  });\n  return observer;\n}\nexport { createCollection, createCollection2 as unstable_createCollection };","map":{"version":3,"names":["React","createContextScope","useComposedRefs","createSlot","jsx","createCollection","name","PROVIDER_NAME","createCollectionContext","createCollectionScope","CollectionProviderImpl","useCollectionContext","collectionRef","current","itemMap","Map","CollectionProvider","props","scope","children","ref","useRef","displayName","COLLECTION_SLOT_NAME","CollectionSlotImpl","CollectionSlot","forwardRef","forwardedRef","context","composedRefs","ITEM_SLOT_NAME","ITEM_DATA_ATTR","CollectionItemSlotImpl","CollectionItemSlot","itemData","_objectWithoutProperties","_excluded","useEffect","set","_objectSpread","delete","useCollection","getItems","useCallback","collectionNode","orderedNodes","Array","from","querySelectorAll","concat","items","values","orderedItems","sort","a","b","indexOf","Provider","Slot","ItemSlot","React2","createContextScope2","useComposedRefs2","createSlot2","__instanciated","WeakMap","OrderedDict","_keys","_OrderedDict","constructor","entries","_classPrivateFieldInitSpec","_classPrivateFieldSet","keys","key","value","get","has","_classPrivateFieldGet","push","insert","index","length","relativeIndex","toSafeInteger","actualIndex","safeIndex","size","nextValue","shouldSkip","i","nextKey","currentKey","currentValue","with","copy","before","entryAt","setBefore","newKey","after","setAfter","first","last","clear","deleted","splice","deleteAt","keyAt","at","offset","dest","keyFrom","find","predicate","thisArg","entry","Reflect","apply","findIndex","filter","map","callbackfn","reduce","_len","arguments","args","_key","initialValue","accumulator","reduceRight","_len2","_key2","toSorted","compareFn","toReversed","reversed","element","toSpliced","slice","start","end","result","stop","every","some","array","prototype","call","toSafeIndex","number","Math","trunc","jsx2","createCollection2","CollectionContextProvider","collectionElement","collectionRefObject","setItemMap","_ref","state","_excluded2","CollectionInit","useInitCollection","setCollectionElement","useState","composeRefs","observer","getChildListObserver","observe","childList","subtree","disconnect","_excluded3","setElement","itemDataRef","shallowEqual","memoizedItemData","itemData2","sortByDocumentPosition","functions","keysA","Object","keysB","hasOwnProperty","isElementPreceding","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","callback","MutationObserver","mutationsList","mutation","type"],"sources":["/app/frontend/node_modules/@radix-ui/react-collection/src/collection-legacy.tsx","/app/frontend/node_modules/@radix-ui/react-collection/src/collection.tsx","/app/frontend/node_modules/@radix-ui/react-collection/src/ordered-dictionary.ts"],"sourcesContent":["import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>â€¦</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement | null>;\n    itemMap: Map<\n      React.RefObject<ItemElement | null>,\n      { ref: React.RefObject<ItemElement | null> } & ItemData\n    >;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n","import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\nimport type { EntryOf } from './ordered-dictionary';\nimport { OrderedDict } from './ordered-dictionary';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\ninterface BaseItemData {\n  id?: string;\n}\n\ntype ItemDataWithElement<\n  ItemData extends BaseItemData,\n  ItemElement extends HTMLElement,\n> = ItemData & {\n  element: ItemElement;\n};\n\ntype ItemMap<ItemElement extends HTMLElement, ItemData extends BaseItemData> = OrderedDict<\n  ItemElement,\n  ItemDataWithElement<ItemData, ItemElement>\n>;\n\nfunction createCollection<\n  ItemElement extends HTMLElement,\n  ItemData extends BaseItemData = BaseItemData,\n>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionElement: CollectionElement | null;\n    collectionRef: React.Ref<CollectionElement | null>;\n    collectionRefObject: React.RefObject<CollectionElement | null>;\n    itemMap: ItemMap<ItemElement, ItemData>;\n    setItemMap: React.Dispatch<React.SetStateAction<ItemMap<ItemElement, ItemData>>>;\n  };\n\n  const [CollectionContextProvider, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    {\n      collectionElement: null,\n      collectionRef: { current: null },\n      collectionRefObject: { current: null },\n      itemMap: new OrderedDict(),\n      setItemMap: () => void 0,\n    }\n  );\n\n  type CollectionState = [\n    ItemMap: ItemMap<ItemElement, ItemData>,\n    SetItemMap: React.Dispatch<React.SetStateAction<ItemMap<ItemElement, ItemData>>>,\n  ];\n\n  const CollectionProvider: React.FC<{\n    children?: React.ReactNode;\n    scope: any;\n    state?: CollectionState;\n  }> = ({ state, ...props }) => {\n    return state ? (\n      <CollectionProviderImpl {...props} state={state} />\n    ) : (\n      <CollectionInit {...props} />\n    );\n  };\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  const CollectionInit: React.FC<{\n    children?: React.ReactNode;\n    scope: any;\n  }> = (props) => {\n    const state = useInitCollection();\n    return <CollectionProviderImpl {...props} state={state} />;\n  };\n  CollectionInit.displayName = PROVIDER_NAME + 'Init';\n\n  const CollectionProviderImpl: React.FC<{\n    children?: React.ReactNode;\n    scope: any;\n    state: CollectionState;\n  }> = (props) => {\n    const { scope, children, state } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const [collectionElement, setCollectionElement] = React.useState<CollectionElement | null>(\n      null\n    );\n    const composeRefs = useComposedRefs(ref, setCollectionElement);\n    const [itemMap, setItemMap] = state;\n\n    React.useEffect(() => {\n      if (!collectionElement) return;\n\n      const observer = getChildListObserver(() => {\n        // setItemMap((map) => {\n        //   const copy = new OrderedDict(map).toSorted(([, a], [, b]) =>\n        //     !a.element || !b.element ? 0 : isElementPreceding(a.element, b.element) ? -1 : 1\n        //   );\n        //   // check if the order has changed\n        //   let index = -1;\n        //   for (const entry of copy) {\n        //     index++;\n        //     const key = map.keyAt(index)!;\n        //     const [copyKey] = entry;\n        //     if (key !== copyKey) {\n        //       // order has changed!\n        //       return copy;\n        //     }\n        //   }\n        //   return map;\n        // });\n      });\n      observer.observe(collectionElement, {\n        childList: true,\n        subtree: true,\n      });\n      return () => {\n        observer.disconnect();\n      };\n    }, [collectionElement]);\n\n    return (\n      <CollectionContextProvider\n        scope={scope}\n        itemMap={itemMap}\n        setItemMap={setItemMap}\n        collectionRef={composeRefs}\n        collectionRefObject={ref}\n        collectionElement={collectionElement}\n      >\n        {children}\n      </CollectionContextProvider>\n    );\n  };\n\n  CollectionProviderImpl.displayName = PROVIDER_NAME + 'Impl';\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const [element, setElement] = React.useState<ItemElement | null>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref, setElement);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      const { setItemMap } = context;\n\n      const itemDataRef = React.useRef(itemData);\n      if (!shallowEqual(itemDataRef.current, itemData)) {\n        itemDataRef.current = itemData;\n      }\n      const memoizedItemData = itemDataRef.current;\n\n      React.useEffect(() => {\n        const itemData = memoizedItemData;\n        setItemMap((map) => {\n          if (!element) {\n            return map;\n          }\n\n          if (!map.has(element)) {\n            map.set(element, { ...(itemData as unknown as ItemData), element });\n            return map.toSorted(sortByDocumentPosition);\n          }\n\n          return map\n            .set(element, { ...(itemData as unknown as ItemData), element })\n            .toSorted(sortByDocumentPosition);\n        });\n\n        return () => {\n          setItemMap((map) => {\n            if (!element || !map.has(element)) {\n              return map;\n            }\n            map.delete(element);\n            return new OrderedDict(map);\n          });\n        };\n      }, [element, memoizedItemData, setItemMap]);\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs as any}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useInitCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useInitCollection() {\n    return React.useState<ItemMap<ItemElement, ItemData>>(new OrderedDict());\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const { itemMap } = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    return itemMap;\n  }\n\n  const functions = {\n    createCollectionScope,\n    useCollection,\n    useInitCollection,\n  };\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    functions,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n\nfunction shallowEqual(a: any, b: any) {\n  if (a === b) return true;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  if (a == null || b == null) return false;\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if (a[key] !== b[key]) return false;\n  }\n  return true;\n}\n\nfunction isElementPreceding(a: Element, b: Element) {\n  return !!(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);\n}\n\nfunction sortByDocumentPosition<E extends HTMLElement, T extends BaseItemData>(\n  a: EntryOf<ItemMap<E, T>>,\n  b: EntryOf<ItemMap<E, T>>\n) {\n  return !a[1].element || !b[1].element\n    ? 0\n    : isElementPreceding(a[1].element, b[1].element)\n      ? -1\n      : 1;\n}\n\nfunction getChildListObserver(callback: () => void) {\n  const observer = new MutationObserver((mutationsList) => {\n    for (const mutation of mutationsList) {\n      if (mutation.type === 'childList') {\n        callback();\n        return;\n      }\n    }\n  });\n\n  return observer;\n}\n","// Not a real member because it shouldn't be accessible, but the super class\n// calls `set` which needs to read the instanciation state, so it can't be a\n// private member.\nconst __instanciated = new WeakMap<OrderedDict<any, any>, boolean>();\nexport class OrderedDict<K, V> extends Map<K, V> {\n  #keys: K[];\n\n  constructor(iterable?: Iterable<readonly [K, V]> | null | undefined);\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    super(entries);\n    this.#keys = [...super.keys()];\n    __instanciated.set(this, true);\n  }\n\n  set(key: K, value: V) {\n    if (__instanciated.get(this)) {\n      if (this.has(key)) {\n        this.#keys[this.#keys.indexOf(key)] = key;\n      } else {\n        this.#keys.push(key);\n      }\n    }\n    super.set(key, value);\n    return this;\n  }\n\n  insert(index: number, key: K, value: V) {\n    const has = this.has(key);\n    const length = this.#keys.length;\n    const relativeIndex = toSafeInteger(index);\n    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n\n    if (safeIndex === this.size || (has && safeIndex === this.size - 1) || safeIndex === -1) {\n      this.set(key, value);\n      return this;\n    }\n\n    const size = this.size + (has ? 0 : 1);\n\n    // If you insert at, say, -2, without this bit you'd replace the\n    // second-to-last item and push the rest up one, which means the new item is\n    // 3rd to last. This isn't very intuitive; inserting at -2 is more like\n    // saying \"make this item the second to last\".\n    if (relativeIndex < 0) {\n      actualIndex++;\n    }\n\n    const keys = [...this.#keys];\n    let nextValue: V | undefined;\n    let shouldSkip = false;\n    for (let i = actualIndex; i < size; i++) {\n      if (actualIndex === i) {\n        let nextKey = keys[i]!;\n        if (keys[i] === key) {\n          nextKey = keys[i + 1]!;\n        }\n        if (has) {\n          // delete first to ensure that the item is moved to the end\n          this.delete(key);\n        }\n        nextValue = this.get(nextKey);\n        this.set(key, value);\n      } else {\n        if (!shouldSkip && keys[i - 1] === key) {\n          shouldSkip = true;\n        }\n        const currentKey = keys[shouldSkip ? i : i - 1]!;\n        const currentValue = nextValue!;\n        nextValue = this.get(currentKey);\n        this.delete(currentKey);\n        this.set(currentKey, currentValue);\n      }\n    }\n    return this;\n  }\n\n  with(index: number, key: K, value: V) {\n    const copy = new OrderedDict(this);\n    copy.insert(index, key, value);\n    return copy;\n  }\n\n  before(key: K) {\n    const index = this.#keys.indexOf(key) - 1;\n    if (index < 0) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position before the given key.\n   */\n  setBefore(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index, newKey, value);\n  }\n\n  after(key: K) {\n    let index = this.#keys.indexOf(key);\n    index = index === -1 || index === this.size - 1 ? -1 : index + 1;\n    if (index === -1) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position after the given key.\n   */\n  setAfter(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index + 1, newKey, value);\n  }\n\n  first() {\n    return this.entryAt(0);\n  }\n\n  last() {\n    return this.entryAt(-1);\n  }\n\n  clear() {\n    this.#keys = [];\n    return super.clear();\n  }\n\n  delete(key: K) {\n    const deleted = super.delete(key);\n    if (deleted) {\n      this.#keys.splice(this.#keys.indexOf(key), 1);\n    }\n    return deleted;\n  }\n\n  deleteAt(index: number) {\n    const key = this.keyAt(index);\n    if (key !== undefined) {\n      return this.delete(key);\n    }\n    return false;\n  }\n\n  at(index: number) {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return this.get(key);\n    }\n  }\n\n  entryAt(index: number): [K, V] | undefined {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return [key, this.get(key)!];\n    }\n  }\n\n  indexOf(key: K) {\n    return this.#keys.indexOf(key);\n  }\n\n  keyAt(index: number) {\n    return at(this.#keys, index);\n  }\n\n  from(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.at(dest);\n  }\n\n  keyFrom(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.keyAt(dest);\n  }\n\n  find(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return entry;\n      }\n      index++;\n    }\n    return undefined;\n  }\n\n  findIndex(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return index;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  filter<KK extends K, VV extends V>(\n    predicate: (entry: [K, V], index: number, dict: OrderedDict<K, V>) => entry is [KK, VV],\n    thisArg?: any\n  ): OrderedDict<KK, VV>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ): OrderedDict<K, V>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    const entries: Array<[K, V]> = [];\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        entries.push(entry);\n      }\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  map<U>(\n    callbackfn: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => U,\n    thisArg?: any\n  ): OrderedDict<K, U> {\n    const entries: [K, U][] = [];\n    let index = 0;\n    for (const entry of this) {\n      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduce<U>(\n    callbackfn: (\n      previousValue: U,\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduce<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let index = 0;\n    let accumulator = initialValue ?? this.at(0)!;\n    for (const entry of this) {\n      if (index === 0 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n      index++;\n    }\n    return accumulator;\n  }\n\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduceRight<U>(\n    callbackfn: (\n      previousValue: [K, V],\n      currentValue: U,\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduceRight<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let accumulator = initialValue ?? this.at(-1)!;\n    for (let index = this.size - 1; index >= 0; index--) {\n      const entry = this.at(index)!;\n      if (index === this.size - 1 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n    }\n    return accumulator;\n  }\n\n  toSorted(compareFn?: (a: [K, V], b: [K, V]) => number): OrderedDict<K, V> {\n    const entries = [...this.entries()].sort(compareFn);\n    return new OrderedDict(entries);\n  }\n\n  toReversed(): OrderedDict<K, V> {\n    const reversed = new OrderedDict<K, V>();\n    for (let index = this.size - 1; index >= 0; index--) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      reversed.set(key, element);\n    }\n    return reversed;\n  }\n\n  toSpliced(start: number, deleteCount?: number): OrderedDict<K, V>;\n  toSpliced(start: number, deleteCount: number, ...items: [K, V][]): OrderedDict<K, V>;\n\n  toSpliced(...args: [start: number, deleteCount: number, ...items: [K, V][]]) {\n    const entries = [...this.entries()];\n    entries.splice(...args);\n    return new OrderedDict(entries);\n  }\n\n  slice(start?: number, end?: number) {\n    const result = new OrderedDict<K, V>();\n    let stop = this.size - 1;\n\n    if (start === undefined) {\n      return result;\n    }\n\n    if (start < 0) {\n      start = start + this.size;\n    }\n\n    if (end !== undefined && end > 0) {\n      stop = end - 1;\n    }\n\n    for (let index = start; index <= stop; index++) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      result.set(key, element);\n    }\n    return result;\n  }\n\n  every(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return false;\n      }\n      index++;\n    }\n    return true;\n  }\n\n  some(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return true;\n      }\n      index++;\n    }\n    return false;\n  }\n}\n\nexport type KeyOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<infer K, any> ? K : never;\nexport type ValueOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<any, infer V> ? V : never;\nexport type EntryOf<D extends OrderedDict<any, any>> = [KeyOf<D>, ValueOf<D>];\nexport type KeyFrom<E extends EntryOf<any>> = E[0];\nexport type ValueFrom<E extends EntryOf<any>> = E[1];\n\nfunction at<T>(array: ArrayLike<T>, index: number): T | undefined {\n  if ('at' in Array.prototype) {\n    return Array.prototype.at.call(array, index);\n  }\n  const actualIndex = toSafeIndex(array, index);\n  return actualIndex === -1 ? undefined : array[actualIndex];\n}\n\nfunction toSafeIndex(array: ArrayLike<any>, index: number) {\n  const length = array.length;\n  const relativeIndex = toSafeInteger(index);\n  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n}\n\nfunction toSafeInteger(number: number) {\n  // eslint-disable-next-line no-self-compare\n  return number !== number || number === 0 ? 0 : Math.trunc(number);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}