{"ast":null,"code":"\"use client\";\n\n// src/popper.tsx\nimport _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"__scopePopper\", \"virtualRef\"],\n  _excluded2 = [\"__scopePopper\", \"side\", \"sideOffset\", \"align\", \"alignOffset\", \"arrowPadding\", \"avoidCollisions\", \"collisionBoundary\", \"collisionPadding\", \"sticky\", \"hideWhenDetached\", \"updatePositionStrategy\", \"onPlaced\"],\n  _excluded3 = [\"__scopePopper\"];\nimport * as React from \"react\";\nimport { useFloating, autoUpdate, offset, shift, limitShift, hide, arrow as floatingUIarrow, flip, size } from \"@floating-ui/react-dom\";\nimport * as ArrowPrimitive from \"@radix-ui/react-arrow\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { useSize } from \"@radix-ui/react-use-size\";\nimport { jsx } from \"react/jsx-runtime\";\nvar SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"];\nvar ALIGN_OPTIONS = [\"start\", \"center\", \"end\"];\nvar POPPER_NAME = \"Popper\";\nvar [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\nvar [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);\nvar Popper = props => {\n  const {\n    __scopePopper,\n    children\n  } = props;\n  const [anchor, setAnchor] = React.useState(null);\n  return /* @__PURE__ */jsx(PopperProvider, {\n    scope: __scopePopper,\n    anchor,\n    onAnchorChange: setAnchor,\n    children\n  });\n};\nPopper.displayName = POPPER_NAME;\nvar ANCHOR_NAME = \"PopperAnchor\";\nvar PopperAnchor = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopePopper,\n      virtualRef\n    } = props,\n    anchorProps = _objectWithoutProperties(props, _excluded);\n  const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const anchorRef = React.useRef(null);\n  React.useEffect(() => {\n    const previousAnchor = anchorRef.current;\n    anchorRef.current = (virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current;\n    if (previousAnchor !== anchorRef.current) {\n      context.onAnchorChange(anchorRef.current);\n    }\n  });\n  return virtualRef ? null : /* @__PURE__ */jsx(Primitive.div, _objectSpread(_objectSpread({}, anchorProps), {}, {\n    ref: composedRefs\n  }));\n});\nPopperAnchor.displayName = ANCHOR_NAME;\nvar CONTENT_NAME = \"PopperContent\";\nvar [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);\nvar PopperContent = React.forwardRef((props, forwardedRef) => {\n  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;\n  const {\n      __scopePopper,\n      side = \"bottom\",\n      sideOffset = 0,\n      align = \"center\",\n      alignOffset = 0,\n      arrowPadding = 0,\n      avoidCollisions = true,\n      collisionBoundary = [],\n      collisionPadding: collisionPaddingProp = 0,\n      sticky = \"partial\",\n      hideWhenDetached = false,\n      updatePositionStrategy = \"optimized\",\n      onPlaced\n    } = props,\n    contentProps = _objectWithoutProperties(props, _excluded2);\n  const context = usePopperContext(CONTENT_NAME, __scopePopper);\n  const [content, setContent] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setContent(node));\n  const [arrow, setArrow] = React.useState(null);\n  const arrowSize = useSize(arrow);\n  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;\n  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;\n  const desiredPlacement = side + (align !== \"center\" ? \"-\" + align : \"\");\n  const collisionPadding = typeof collisionPaddingProp === \"number\" ? collisionPaddingProp : _objectSpread({\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }, collisionPaddingProp);\n  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n  const hasExplicitBoundaries = boundary.length > 0;\n  const detectOverflowOptions = {\n    padding: collisionPadding,\n    boundary: boundary.filter(isNotNull),\n    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n    altBoundary: hasExplicitBoundaries\n  };\n  const {\n    refs,\n    floatingStyles,\n    placement,\n    isPositioned,\n    middlewareData\n  } = useFloating({\n    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n    strategy: \"fixed\",\n    placement: desiredPlacement,\n    whileElementsMounted: function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const cleanup = autoUpdate(...args, {\n        animationFrame: updatePositionStrategy === \"always\"\n      });\n      return cleanup;\n    },\n    elements: {\n      reference: context.anchor\n    },\n    middleware: [offset({\n      mainAxis: sideOffset + arrowHeight,\n      alignmentAxis: alignOffset\n    }), avoidCollisions && shift(_objectSpread({\n      mainAxis: true,\n      crossAxis: false,\n      limiter: sticky === \"partial\" ? limitShift() : void 0\n    }, detectOverflowOptions)), avoidCollisions && flip(_objectSpread({}, detectOverflowOptions)), size(_objectSpread(_objectSpread({}, detectOverflowOptions), {}, {\n      apply: _ref => {\n        let {\n          elements,\n          rects,\n          availableWidth,\n          availableHeight\n        } = _ref;\n        const {\n          width: anchorWidth,\n          height: anchorHeight\n        } = rects.reference;\n        const contentStyle = elements.floating.style;\n        contentStyle.setProperty(\"--radix-popper-available-width\", \"\".concat(availableWidth, \"px\"));\n        contentStyle.setProperty(\"--radix-popper-available-height\", \"\".concat(availableHeight, \"px\"));\n        contentStyle.setProperty(\"--radix-popper-anchor-width\", \"\".concat(anchorWidth, \"px\"));\n        contentStyle.setProperty(\"--radix-popper-anchor-height\", \"\".concat(anchorHeight, \"px\"));\n      }\n    })), arrow && floatingUIarrow({\n      element: arrow,\n      padding: arrowPadding\n    }), transformOrigin({\n      arrowWidth,\n      arrowHeight\n    }), hideWhenDetached && hide(_objectSpread({\n      strategy: \"referenceHidden\"\n    }, detectOverflowOptions))]\n  });\n  const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n  const handlePlaced = useCallbackRef(onPlaced);\n  useLayoutEffect(() => {\n    if (isPositioned) {\n      handlePlaced === null || handlePlaced === void 0 || handlePlaced();\n    }\n  }, [isPositioned, handlePlaced]);\n  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;\n  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;\n  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;\n  const [contentZIndex, setContentZIndex] = React.useState();\n  useLayoutEffect(() => {\n    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n  }, [content]);\n  return /* @__PURE__ */jsx(\"div\", {\n    ref: refs.setFloating,\n    \"data-radix-popper-content-wrapper\": \"\",\n    style: _objectSpread(_objectSpread({}, floatingStyles), {}, {\n      transform: isPositioned ? floatingStyles.transform : \"translate(0, -200%)\",\n      // keep off the page when measuring\n      minWidth: \"max-content\",\n      zIndex: contentZIndex,\n      [\"--radix-popper-transform-origin\"]: [(_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x, (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y].join(\" \")\n    }, ((_middlewareData$hide = middlewareData.hide) === null || _middlewareData$hide === void 0 ? void 0 : _middlewareData$hide.referenceHidden) && {\n      visibility: \"hidden\",\n      pointerEvents: \"none\"\n    }),\n    dir: props.dir,\n    children: /* @__PURE__ */jsx(PopperContentProvider, {\n      scope: __scopePopper,\n      placedSide,\n      onArrowChange: setArrow,\n      arrowX,\n      arrowY,\n      shouldHideArrow: cannotCenterArrow,\n      children: /* @__PURE__ */jsx(Primitive.div, _objectSpread(_objectSpread({\n        \"data-side\": placedSide,\n        \"data-align\": placedAlign\n      }, contentProps), {}, {\n        ref: composedRefs,\n        style: _objectSpread(_objectSpread({}, contentProps.style), {}, {\n          // if the PopperContent hasn't been placed yet (not all measurements done)\n          // we prevent animations so that users's animation don't kick in too early referring wrong sides\n          animation: !isPositioned ? \"none\" : void 0\n        })\n      }))\n    })\n  });\n});\nPopperContent.displayName = CONTENT_NAME;\nvar ARROW_NAME = \"PopperArrow\";\nvar OPPOSITE_SIDE = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\nvar PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {\n  const {\n      __scopePopper\n    } = props,\n    arrowProps = _objectWithoutProperties(props, _excluded3);\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    /* @__PURE__ */\n    jsx(\"span\", {\n      ref: contentContext.onArrowChange,\n      style: {\n        position: \"absolute\",\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: \"\",\n          right: \"0 0\",\n          bottom: \"center 0\",\n          left: \"100% 0\"\n        }[contentContext.placedSide],\n        transform: {\n          top: \"translateY(100%)\",\n          right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n          bottom: \"rotate(180deg)\",\n          left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? \"hidden\" : void 0\n      },\n      children: /* @__PURE__ */jsx(ArrowPrimitive.Root, _objectSpread(_objectSpread({}, arrowProps), {}, {\n        ref: forwardedRef,\n        style: _objectSpread(_objectSpread({}, arrowProps.style), {}, {\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: \"block\"\n        })\n      }))\n    })\n  );\n});\nPopperArrow.displayName = ARROW_NAME;\nfunction isNotNull(value) {\n  return value !== null;\n}\nvar transformOrigin = options => ({\n  name: \"transformOrigin\",\n  options,\n  fn(data) {\n    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;\n    const {\n      placement,\n      rects,\n      middlewareData\n    } = data;\n    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = {\n      start: \"0%\",\n      center: \"50%\",\n      end: \"100%\"\n    }[placedAlign];\n    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;\n    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;\n    let x = \"\";\n    let y = \"\";\n    if (placedSide === \"bottom\") {\n      x = isArrowHidden ? noArrowAlign : \"\".concat(arrowXCenter, \"px\");\n      y = \"\".concat(-arrowHeight, \"px\");\n    } else if (placedSide === \"top\") {\n      x = isArrowHidden ? noArrowAlign : \"\".concat(arrowXCenter, \"px\");\n      y = \"\".concat(rects.floating.height + arrowHeight, \"px\");\n    } else if (placedSide === \"right\") {\n      x = \"\".concat(-arrowHeight, \"px\");\n      y = isArrowHidden ? noArrowAlign : \"\".concat(arrowYCenter, \"px\");\n    } else if (placedSide === \"left\") {\n      x = \"\".concat(rects.floating.width + arrowHeight, \"px\");\n      y = isArrowHidden ? noArrowAlign : \"\".concat(arrowYCenter, \"px\");\n    }\n    return {\n      data: {\n        x,\n        y\n      }\n    };\n  }\n});\nfunction getSideAndAlignFromPlacement(placement) {\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return [side, align];\n}\nvar Root2 = Popper;\nvar Anchor = PopperAnchor;\nvar Content = PopperContent;\nvar Arrow = PopperArrow;\nexport { ALIGN_OPTIONS, Anchor, Arrow, Content, Popper, PopperAnchor, PopperArrow, PopperContent, Root2 as Root, SIDE_OPTIONS, createPopperScope };","map":{"version":3,"names":["React","useFloating","autoUpdate","offset","shift","limitShift","hide","arrow","floatingUIarrow","flip","size","ArrowPrimitive","useComposedRefs","createContextScope","Primitive","useCallbackRef","useLayoutEffect","useSize","jsx","SIDE_OPTIONS","ALIGN_OPTIONS","POPPER_NAME","createPopperContext","createPopperScope","PopperProvider","usePopperContext","Popper","props","__scopePopper","children","anchor","setAnchor","useState","scope","onAnchorChange","displayName","ANCHOR_NAME","PopperAnchor","forwardRef","forwardedRef","virtualRef","anchorProps","_objectWithoutProperties","_excluded","context","ref","useRef","composedRefs","anchorRef","useEffect","previousAnchor","current","div","_objectSpread","CONTENT_NAME","PopperContentProvider","useContentContext","PopperContent","_arrowSize$width","_arrowSize$height","_middlewareData$arrow","_middlewareData$arrow2","_middlewareData$arrow3","_middlewareData$trans","_middlewareData$trans2","_middlewareData$hide","side","sideOffset","align","alignOffset","arrowPadding","avoidCollisions","collisionBoundary","collisionPadding","collisionPaddingProp","sticky","hideWhenDetached","updatePositionStrategy","onPlaced","contentProps","_excluded2","content","setContent","node","setArrow","arrowSize","arrowWidth","width","arrowHeight","height","desiredPlacement","top","right","bottom","left","boundary","Array","isArray","hasExplicitBoundaries","length","detectOverflowOptions","padding","filter","isNotNull","altBoundary","refs","floatingStyles","placement","isPositioned","middlewareData","strategy","whileElementsMounted","_len","arguments","args","_key","cleanup","animationFrame","elements","reference","middleware","mainAxis","alignmentAxis","crossAxis","limiter","apply","_ref","rects","availableWidth","availableHeight","anchorWidth","anchorHeight","contentStyle","floating","style","setProperty","concat","element","transformOrigin","placedSide","placedAlign","getSideAndAlignFromPlacement","handlePlaced","arrowX","x","arrowY","y","cannotCenterArrow","centerOffset","contentZIndex","setContentZIndex","window","getComputedStyle","zIndex","setFloating","transform","minWidth","join","referenceHidden","visibility","pointerEvents","dir","onArrowChange","shouldHideArrow","animation","ARROW_NAME","OPPOSITE_SIDE","PopperArrow","PopperArrow2","arrowProps","_excluded3","contentContext","baseSide","position","Root","display","value","options","name","fn","data","_middlewareData$arrow4","_middlewareData$arrow5","_middlewareData$arrow6","_middlewareData$arrow7","_middlewareData$arrow8","isArrowHidden","noArrowAlign","start","center","end","arrowXCenter","arrowYCenter","split","Root2","Anchor","Content","Arrow"],"sources":["/app/frontend/node_modules/@radix-ui/react-popper/src/popper.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  useFloating,\n  autoUpdate,\n  offset,\n  shift,\n  limitShift,\n  hide,\n  arrow as floatingUIarrow,\n  flip,\n  size,\n} from '@floating-ui/react-dom';\nimport * as ArrowPrimitive from '@radix-ui/react-arrow';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useSize } from '@radix-ui/react-use-size';\n\nimport type { Placement, Middleware } from '@floating-ui/react-dom';\nimport type { Scope } from '@radix-ui/react-context';\nimport type { Measurable } from '@radix-ui/rect';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Side = (typeof SIDE_OPTIONS)[number];\ntype Align = (typeof ALIGN_OPTIONS)[number];\n\n/* -------------------------------------------------------------------------------------------------\n * Popper\n * -----------------------------------------------------------------------------------------------*/\n\nconst POPPER_NAME = 'Popper';\n\ntype ScopedProps<P> = P & { __scopePopper?: Scope };\nconst [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\n\ntype PopperContextValue = {\n  anchor: Measurable | null;\n  onAnchorChange(anchor: Measurable | null): void;\n};\nconst [PopperProvider, usePopperContext] = createPopperContext<PopperContextValue>(POPPER_NAME);\n\ninterface PopperProps {\n  children?: React.ReactNode;\n}\nconst Popper: React.FC<PopperProps> = (props: ScopedProps<PopperProps>) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = React.useState<Measurable | null>(null);\n  return (\n    <PopperProvider scope={__scopePopper} anchor={anchor} onAnchorChange={setAnchor}>\n      {children}\n    </PopperProvider>\n  );\n};\n\nPopper.displayName = POPPER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'PopperAnchor';\n\ntype PopperAnchorElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PopperAnchorProps extends PrimitiveDivProps {\n  virtualRef?: React.RefObject<Measurable>;\n}\n\nconst PopperAnchor = React.forwardRef<PopperAnchorElement, PopperAnchorProps>(\n  (props: ScopedProps<PopperAnchorProps>, forwardedRef) => {\n    const { __scopePopper, virtualRef, ...anchorProps } = props;\n    const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n    const ref = React.useRef<PopperAnchorElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    const anchorRef = React.useRef<Measurable | null>(null);\n    React.useEffect(() => {\n      const previousAnchor = anchorRef.current;\n      anchorRef.current = virtualRef?.current || ref.current;\n      if (previousAnchor !== anchorRef.current) {\n        // Consumer can anchor the popper to something that isn't\n        // a DOM node e.g. pointer position, so we override the\n        // `anchorRef` with their virtual ref in this case.\n        context.onAnchorChange(anchorRef.current);\n      }\n    });\n\n    return virtualRef ? null : <Primitive.div {...anchorProps} ref={composedRefs} />;\n  }\n);\n\nPopperAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'PopperContent';\n\ntype PopperContentContextValue = {\n  placedSide: Side;\n  onArrowChange(arrow: HTMLSpanElement | null): void;\n  arrowX?: number;\n  arrowY?: number;\n  shouldHideArrow: boolean;\n};\n\nconst [PopperContentProvider, useContentContext] =\n  createPopperContext<PopperContentContextValue>(CONTENT_NAME);\n\ntype Boundary = Element | null;\n\ntype PopperContentElement = React.ComponentRef<typeof Primitive.div>;\ninterface PopperContentProps extends PrimitiveDivProps {\n  side?: Side;\n  sideOffset?: number;\n  align?: Align;\n  alignOffset?: number;\n  arrowPadding?: number;\n  avoidCollisions?: boolean;\n  collisionBoundary?: Boundary | Boundary[];\n  collisionPadding?: number | Partial<Record<Side, number>>;\n  sticky?: 'partial' | 'always';\n  hideWhenDetached?: boolean;\n  updatePositionStrategy?: 'optimized' | 'always';\n  onPlaced?: () => void;\n}\n\nconst PopperContent = React.forwardRef<PopperContentElement, PopperContentProps>(\n  (props: ScopedProps<PopperContentProps>, forwardedRef) => {\n    const {\n      __scopePopper,\n      side = 'bottom',\n      sideOffset = 0,\n      align = 'center',\n      alignOffset = 0,\n      arrowPadding = 0,\n      avoidCollisions = true,\n      collisionBoundary = [],\n      collisionPadding: collisionPaddingProp = 0,\n      sticky = 'partial',\n      hideWhenDetached = false,\n      updatePositionStrategy = 'optimized',\n      onPlaced,\n      ...contentProps\n    } = props;\n\n    const context = usePopperContext(CONTENT_NAME, __scopePopper);\n\n    const [content, setContent] = React.useState<HTMLDivElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n\n    const [arrow, setArrow] = React.useState<HTMLSpanElement | null>(null);\n    const arrowSize = useSize(arrow);\n    const arrowWidth = arrowSize?.width ?? 0;\n    const arrowHeight = arrowSize?.height ?? 0;\n\n    const desiredPlacement = (side + (align !== 'center' ? '-' + align : '')) as Placement;\n\n    const collisionPadding =\n      typeof collisionPaddingProp === 'number'\n        ? collisionPaddingProp\n        : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };\n\n    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n    const hasExplicitBoundaries = boundary.length > 0;\n\n    const detectOverflowOptions = {\n      padding: collisionPadding,\n      boundary: boundary.filter(isNotNull),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: hasExplicitBoundaries,\n    };\n\n    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({\n      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n      strategy: 'fixed',\n      placement: desiredPlacement,\n      whileElementsMounted: (...args) => {\n        const cleanup = autoUpdate(...args, {\n          animationFrame: updatePositionStrategy === 'always',\n        });\n        return cleanup;\n      },\n      elements: {\n        reference: context.anchor,\n      },\n      middleware: [\n        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),\n        avoidCollisions &&\n          shift({\n            mainAxis: true,\n            crossAxis: false,\n            limiter: sticky === 'partial' ? limitShift() : undefined,\n            ...detectOverflowOptions,\n          }),\n        avoidCollisions && flip({ ...detectOverflowOptions }),\n        size({\n          ...detectOverflowOptions,\n          apply: ({ elements, rects, availableWidth, availableHeight }) => {\n            const { width: anchorWidth, height: anchorHeight } = rects.reference;\n            const contentStyle = elements.floating.style;\n            contentStyle.setProperty('--radix-popper-available-width', `${availableWidth}px`);\n            contentStyle.setProperty('--radix-popper-available-height', `${availableHeight}px`);\n            contentStyle.setProperty('--radix-popper-anchor-width', `${anchorWidth}px`);\n            contentStyle.setProperty('--radix-popper-anchor-height', `${anchorHeight}px`);\n          },\n        }),\n        arrow && floatingUIarrow({ element: arrow, padding: arrowPadding }),\n        transformOrigin({ arrowWidth, arrowHeight }),\n        hideWhenDetached && hide({ strategy: 'referenceHidden', ...detectOverflowOptions }),\n      ],\n    });\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n\n    const handlePlaced = useCallbackRef(onPlaced);\n    useLayoutEffect(() => {\n      if (isPositioned) {\n        handlePlaced?.();\n      }\n    }, [isPositioned, handlePlaced]);\n\n    const arrowX = middlewareData.arrow?.x;\n    const arrowY = middlewareData.arrow?.y;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n\n    const [contentZIndex, setContentZIndex] = React.useState<string>();\n    useLayoutEffect(() => {\n      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n    }, [content]);\n\n    return (\n      <div\n        ref={refs.setFloating}\n        data-radix-popper-content-wrapper=\"\"\n        style={{\n          ...floatingStyles,\n          transform: isPositioned ? floatingStyles.transform : 'translate(0, -200%)', // keep off the page when measuring\n          minWidth: 'max-content',\n          zIndex: contentZIndex,\n          ['--radix-popper-transform-origin' as any]: [\n            middlewareData.transformOrigin?.x,\n            middlewareData.transformOrigin?.y,\n          ].join(' '),\n\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...(middlewareData.hide?.referenceHidden && {\n            visibility: 'hidden',\n            pointerEvents: 'none',\n          }),\n        }}\n        // Floating UI interally calculates logical alignment based the `dir` attribute on\n        // the reference/floating node, we must add this attribute here to ensure\n        // this is calculated when portalled as well as inline.\n        dir={props.dir}\n      >\n        <PopperContentProvider\n          scope={__scopePopper}\n          placedSide={placedSide}\n          onArrowChange={setArrow}\n          arrowX={arrowX}\n          arrowY={arrowY}\n          shouldHideArrow={cannotCenterArrow}\n        >\n          <Primitive.div\n            data-side={placedSide}\n            data-align={placedAlign}\n            {...contentProps}\n            ref={composedRefs}\n            style={{\n              ...contentProps.style,\n              // if the PopperContent hasn't been placed yet (not all measurements done)\n              // we prevent animations so that users's animation don't kick in too early referring wrong sides\n              animation: !isPositioned ? 'none' : undefined,\n            }}\n          />\n        </PopperContentProvider>\n      </div>\n    );\n  }\n);\n\nPopperContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'PopperArrow';\n\nconst OPPOSITE_SIDE: Record<Side, Side> = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n};\n\ntype PopperArrowElement = React.ComponentRef<typeof ArrowPrimitive.Root>;\ntype ArrowProps = React.ComponentPropsWithoutRef<typeof ArrowPrimitive.Root>;\ninterface PopperArrowProps extends ArrowProps {}\n\nconst PopperArrow = React.forwardRef<PopperArrowElement, PopperArrowProps>(function PopperArrow(\n  props: ScopedProps<PopperArrowProps>,\n  forwardedRef\n) {\n  const { __scopePopper, ...arrowProps } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    <span\n      ref={contentContext.onArrowChange}\n      style={{\n        position: 'absolute',\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: '',\n          right: '0 0',\n          bottom: 'center 0',\n          left: '100% 0',\n        }[contentContext.placedSide],\n        transform: {\n          top: 'translateY(100%)',\n          right: 'translateY(50%) rotate(90deg) translateX(-50%)',\n          bottom: `rotate(180deg)`,\n          left: 'translateY(50%) rotate(-90deg) translateX(50%)',\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? 'hidden' : undefined,\n      }}\n    >\n      <ArrowPrimitive.Root\n        {...arrowProps}\n        ref={forwardedRef}\n        style={{\n          ...arrowProps.style,\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: 'block',\n        }}\n      />\n    </span>\n  );\n});\n\nPopperArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\nconst transformOrigin = (options: { arrowWidth: number; arrowHeight: number }): Middleware => ({\n  name: 'transformOrigin',\n  options,\n  fn(data) {\n    const { placement, rects, middlewareData } = data;\n\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = { start: '0%', center: '50%', end: '100%' }[placedAlign];\n\n    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n\n    let x = '';\n    let y = '';\n\n    if (placedSide === 'bottom') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${-arrowHeight}px`;\n    } else if (placedSide === 'top') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === 'right') {\n      x = `${-arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === 'left') {\n      x = `${rects.floating.width + arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return { data: { x, y } };\n  },\n});\n\nfunction getSideAndAlignFromPlacement(placement: Placement) {\n  const [side, align = 'center'] = placement.split('-');\n  return [side as Side, align as Align] as const;\n}\n\nconst Root = Popper;\nconst Anchor = PopperAnchor;\nconst Content = PopperContent;\nconst Arrow = PopperArrow;\n\nexport {\n  createPopperScope,\n  //\n  Popper,\n  PopperAnchor,\n  PopperContent,\n  PopperArrow,\n  //\n  Root,\n  Anchor,\n  Content,\n  Arrow,\n  //\n  SIDE_OPTIONS,\n  ALIGN_OPTIONS,\n};\nexport type { PopperProps, PopperAnchorProps, PopperContentProps, PopperArrowProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}